/** This file provides a convenient functional interface to the SESync
* algorithm.
*
*  Copyright (C) 2016, 2017 by David M. Rosen
*/

#pragma once

#include <vector>

#include <Eigen/Dense>

#include "SESync/RelativePoseMeasurement.h"
#include "SESync/SESyncProblem.h"
#include "SESync/SESync_types.h"

namespace SESync {

/** This struct contains the various parameters that control the SESync
 * algorithm */
struct SESyncOpts {
  /// OPTIMIZATION STOPPING CRITERIA

  /** Stopping tolerance for the norm of the Riemannian gradient */
  double grad_norm_tol = 1e-2;

  /** Stopping criterion based upon the relative decrease in function value */
  double rel_func_decrease_tol = 1e-7;

  /** Stopping criterion based upon the norm of an accepted update step */
  double stepsize_tol = 1e-3;

  /** Maximum permitted number of (outer) iterations of the Riemannian
   * trust-region method when solving each instance of Problem 9 */
  unsigned int max_iterations = 500;

  /** Maximum number of inner (truncated conjugate-gradient) iterations to
 * perform per out iteration */
  unsigned int max_tCG_iterations = 2000;

  /** Maximum elapsed computation time (in seconds) */
  double max_computation_time = std::numeric_limits<double>::max();

  /// SE-SYNC PARAMETERS

  /** The specific formulation of the SE-Sync problem to solve */
  Formulation formulation = Simplified;

  /** The initial level of the Riemannian Staircase */
  unsigned int r0 = 5;

  /** The maximum level of the Riemannian Staircase to explore */
  unsigned int rmax = 10;

  /** The maximum number of Lanczos iterations to admit for eigenvalue
 * computations */
  unsigned int max_eig_iterations = 10000;

  /** A numerical tolerance for acceptance of the minimum eigenvalue of Q -
 * Lambda(Y*) as numerically nonnegative; this should be a small magnitude value
 * e.g. 10^-4 */
  double min_eig_num_tol = 1e-5;

  /** The number of working vectors to use in the minimum eigenvalue computation
(using the implicitly-restarted Arnoldi algorithm); must be in the range [1,
(#poses) * (#problem dimension) - 1] */
  unsigned int num_Lanczos_vectors = 20;

  /** If no initial iterate Y0 is supplied, this boolean determines the
 * initialization strategy employed by SE-Sync: 'true' -> chordal, 'false' ->
 * random sampling */
  bool use_chordal_initialization = true;

  /** Whether to use the Cholesky or QR factorization when computing the
   * orthogonal projection */
  bool use_Cholesky = true;

  /** The preconditioning strategy to use in the Riemannian trust-region
   * algorithm*/
  Preconditioner precon = IncompleteCholesky;

  /** Whether to print output as the algorithm runs */
  bool verbose = false;

  /** If this value is true, the SE-Sync algorithm will log and return the
   * entire sequence of iterates generated by the Riemannian Staircase */
  bool log_iterates = false;

  /** The number of threads to use for parallelization (assuming that SE-Sync is
   * built using a compiler that supports OpenMP */
  unsigned int num_threads = 1;
};

/** These enumerations describe the termination status of the SE-Sync algorithm
 */
enum SESyncStatus {
  /** The algorithm converged to a certified global optimum */
  GLOBAL_OPT,

  /** The algorithm converged to a saddle point, but the backtracking line
     search was unable to escape it */
  SADDLE_POINT,

  /** The algorithm converged to a first-order critical point, but the
     minimum-eigenvalue computation did not converge to sufficient precision to
     enable its characterization */
  EIG_IMPRECISION,

  /** The algorithm exhausted the maximum number of iterations of the Riemannian
     Staircase before finding an optimal solution */
  RS_ITER_LIMIT,

  /** The algorithm exhausted the allotted total computation time before finding
     an optimal solution */
  ELAPSED_TIME
};

/** This struct contains the output of the SESync algorithm */
struct SESyncResult {
  /** The optimal value of the SDP relaxation */
  double SDPval;

  /** A global minimizer Yopt of the rank-restricted semidefinite relaxation */
  Matrix Yopt;

  /** The norm of the Riemannian gradient at Yopt */
  double gradnorm;

  /** The minimum eigenvalue of the matrix S - Lambda(Yopt) */
  double lambda_min;

  /** The corresponding eigenvector of the minimum eigenvalue */
  Vector v_min;

  /** The value of the rounded solution xhat in SE(d)^n */
  double Fxhat;

  /** The rounded solution xhat = [t | R] in SE(d)^n */
  Matrix xhat;

  /** The total elapsed computation time for the SE-Sync algorithm */
  double total_computation_time;

  /** The elapsed computation time used to compute the initialization for the
   * Riemannian Staircase */
  double initialization_time;

  /** A vector containing the sequence of function values obtained during the
   * optimization at each level of the Riemannian Staircase */
  std::vector<std::vector<double>> function_values;

  /** A vector containing the sequence of norms of the Riemannian gradients
   * obtained during the optimization at each level of the Riemannian Staircase
   */
  std::vector<std::vector<double>> gradient_norms;

  /** A vector containing the sequence of elapsed times in the optimization at
   * each level of the Riemannian Staircase at which the corresponding function
   * values and gradients were obtained */
  std::vector<std::vector<double>> elapsed_optimization_times;

  /** A vector containing the sequence of minimum eigenvalues of the certificate
   * matrix constructed from the critical point recovered from the
   * optimization at each level of the Riemannian Staircase */
  std::vector<double> minimum_eigenvalues;

  /** A vector containing the elapsed time of the minimum eigenvalue computation
   * at each level of the Riemannian Staircase */
  std::vector<double> minimum_eigenvalue_computation_times;

  /** If SE-Sync was run with log_iterates = true, this vector will contain the
   * entire sequence of iterates generated by the Riemannian Staircase */
  std::vector<Matrix> iterates;

  SESyncStatus status;
};

/** Given a vector of relative pose measurements specifying a special Euclidean
 * synchronization problem, performs synchronization using the SESync algorithm
 */
SESyncResult SESync(const std::vector<RelativePoseMeasurement> &measurements,
                    const SESyncOpts &options = SESyncOpts(),
                    const Matrix &Y0 = Matrix());

/** Helper function: used in the Riemannian Staircase to escape from a saddle
 * point.  Here:
 *
 * - problem is the specific special Euclidean synchronization problem we are
 *     attempting to solve
 * - Y is the critical point (saddle point) obtained at the current level of the
 *     Riemannian Staircase
 * - lambda_min is the (negative) minimum eigenvalue of the matrix Q - Lambda
 * - v_min is the eigenvector corresponding to lambda_min
 * - gradient_tolerance is a *lower bound* on the norm of the Riemannian
 * gradient grad F(Yplus)
 *     in order to accept a candidate point Xplus as a valid solution
 *
 * Post-condition:  This function returns a Boolean value indicating whether it
 * was able to successfully escape from the saddle point, meaning it found a
 * point Yplus satisfying the following two criteria:
 *
 *  (1)  F(Yplus) < F(Y), and
 *  (2)  || grad F(Yplus) || > gradient_tolerance
 *
 * Condition (2) above is necessary to ensure that the optimization initialized
 * at the next level of the Riemannian Staircase does not immediately terminate
 * due to the gradient stopping tolerance being satisfied.
 *
 * Precondition: the relaxation rank r of 'problem' must be 1 greater than the
 * number of rows of Y (i.e., the relaxation rank of 'problem' must already be
 * set for the *next* level of the Riemannian Staircase when this function is
 * called.
 *
 * Postcondition: If this function returns true, then upon termination Yplus
 * contains the point at which to initialize the optimization at the next level
 * of the Riemannian Staircase
 */
bool escape_saddle(const SESyncProblem &problem, const Matrix &Y,
                   double lambda_min, const Vector &v_min,
                   double gradient_tolerance, Matrix &Yplus);

} // namespace SESync
